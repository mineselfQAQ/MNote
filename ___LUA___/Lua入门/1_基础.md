**<center><BG>1_基础</BG></center>**

<!-- TOC -->

- [基础中的基础](#%E5%9F%BA%E7%A1%80%E4%B8%AD%E7%9A%84%E5%9F%BA%E7%A1%80)
- [数据类型](#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B)
- [库](#%E5%BA%93)

<!-- /TOC -->

# 1.基础中的基础

**<BL>问题：Lua是什么</BL>**
<BL>Lua是一种轻量化的*嵌入式*语言，可以嵌入应用程序中，这意味着：在游戏中可以为本体进行灵活的扩展和定制功能</BL>

**一些知识点：**
- **<GN>chunk</GN>**---程序块，为**一连串的语句或命令**
- Lua**区分大小写**
- 未初始化的变量可以直接访问，为nil
- 不添加前缀就是<GN>全局变量</GN>，添加local前缀就是<GN>局部变量</GN>
- 索引起始值为1(否则某些机制无法使用)
- `a = a or 0`，一种**默认值**的设置方式
- `zip = (address or {}).zipcode`，一种**类的安全访问**的方式
- `x, y = y, x`，一种**交换**的方式
- Lua支持多重赋值，如`a, b = 10, 2*10`　所以：`a,b,c = 0`是不对的，应该为`a,b,c = 0,0,0`
- 通过`do ... end`添加块　　<VT>类似与C#的`{ ... }`</VT>
  由此可以创建出**不污染全局的局部变量**：

  ``` lua
  foo = 10
  do
    --创建局部的foo，在此之后end之前foo都是局部的
     local foo = foo
     foo = 1
     print(foo) -- 局部，得1
  end
  print(foo) -- 全局，得10
  ```

# 2.数据类型

**在Lua中有以下类型：**
nil | boolean | number | string | userdata | function | thread | table

**<GN>number</GN>**

**<DRD>注意：从Lua5.3开始，number非拆分成了integer(整型)与float(浮点型)</DRD>**
在5.3之前：
所有数值都是**双精度浮点格式**
在5.3之后：
integer-**64位整型** | float-**双精度浮点类型**
(可以通过Small Lua模式<VT>(好像是通过LUA_32BITS宏？)</VT>改用32位整型与单精度浮点类型)

**Tip：**

- 可以通过`math.maxinteger`/`math.mininteger`表示整型的最大值/最小值
- 可以通过`math.huge`/`-math.huge`表示浮点型的最大值/最小值
- **整型转浮点型**可以通过**+0.0**　　　<YL>如：`-3+0.0为`-3.0`</YL>
- **浮点型转整型**，有两种方式：按位或 | `math.tointeger()`
  两种都会进行检查：
  - `2^53 | 0`为`9007199254740992`
  - `3.2 | 0`　　　<VT>不可以，因为3.2和3不相等</VT>
  - `2^64 | 0`　　　<VT>不可以，超范围了</VT>
- 大于2^53的整型转浮点型会造成精度损失
- 浮点型强转整型的话可以改造以下函数：

    ``` lua
    function cond2int(x)
        -- 转换失败会返回nil，那么失败就还原
        return math.tointeger(x) or x
    end
    ```

**优先级**如下所示：　　**<VT>优先级从高到低</VT>**
![优先级](Pic/优先级.png)
**结合律**如下所示：
**除了`^`和`..`为右结合，其余皆为左结合**

**<GN>string</GN>**

单行注释---`--`
多行注释---`[[ ... ]]`　　<VT>类似与C#的`@`</VT>

- **string转其它类型**---toXXX()　　<YL>如：`tonumber()`</YL>
- **其它类型转string**：
  - `tostring()`
  - `xx .. ""`　　<VT>即<b>添加空字符串</b></VT>

对于string来说，有**2个库**：

- **<GN>string库</GN>**---<VT>对ASCII操作</VT>
- **<GN>utf8库</GN>**---<VT>对utf8操作</VT>
  
**<DRD>注意：string库的内容还是可以用于utf8字符串的，只是形式有所变化(如：`string.len()`会以字节为单位)</DRD>**

**<GN>table</GN>**

table具有**唯一的创建方式**，即`{}`
具体来说有：

- 1.`days = {"Sunday", "Monday"}`
- 2.`a = {x=10, y=20}`
- 3.`opnames = {["+"] = "add", ["-"] = "sub"}` 可以使用负数

我们可以认为1/2形式其实是3形式的**语法糖**

**语法糖：**`a["name"] == a.name`　　**<DRD>注意：是a["name"]而非a[name]</DRD>**

**<VT>问题：如何以索引0开始</VT>**
`{[0] = 0, 1, 2, 3, 4}`　　**<DRD>注意：极其不推荐，因为有些内容需要起始索引为1的特性</DRD>**

**Tip：分割不仅可以是`,`，还可以是`;`**，在某些时候可以起到小分割与大分割的作用
**<YL>如：</YL>**`t = {x=10, y=45; "one", "two", "three"}`

**nil是数组结尾的标志**，有：

``` lua
a = {}
a[10000] = 1
print(#a) -- 0，按理来说应该是1
```

由此，我们可以编写一个<b><GN>长度函数len()</GN></b>:

``` lua
-- 通过pairs进行完整遍历，输出完整长度
local function len(x)
    local n = 0;
    for k,v in pairs(x) do
        n = n + 1
    end
    return n
end
```

**<GN>function</GN>**

一般函数的形式为：`print("OK")`
但是存在一种**特例**：**<VT>如果函数只有一个参数(必须是<DRD>字面字符串或table构造式</DRD>)，那么可以省略括号(指的是调用时只有一个)</VT>**
**<YL>如：</YL>**`print("OK")`--->`print "OK"`　`require("a")`--->`require "a"`

在Lua中，**参数列表是不需要匹配**的：

- 假如多传参了，那么多的就会丢弃，
- 假如少传参了，那么少的就会置为nil

由此可以应用在如下情况：

``` lua
function incCount(n)
  -- n可以不传，不传就设默认值1
  n = n or 1
  count = count + n
end
```

**特性：<GN>多返回值</GN>**
`function foo() return "a", "b" end`
**关键点：<VT>如果函数调用不是表达式的最后一个元素，那么只产生一个值(对于table初始化来说同理)</VT>**

``` lua
function foo0() end
function foo2() return "a", "b" end

x = foo2() -- x="a"，"b"被丢弃
x,y,z = foo2() -- x="a"，y="b"，z未赋值为nil

x,y = foo2(), 20 -- x="a"(只取第一个"a"，"b"被丢弃了)， y=20
x,y = foo0(), 20, 30 -- x=nil(foo0赋值的)，y=20，30被丢弃

print(foo2()) -- a b
print(foo2(), 1) -- a 1

-- table同理
t = {foo0(), foo2(), 4} -- [1]=nil [2]="a" [3]=4
```

**Tip：括号能使多返回值函数只返回1个值**

``` lua
function multipleReturns()
    return 1, 2, 3
end
local t1 = {multipleReturns()}  -- t1 = {1, 2, 3}
local t2 = {(multipleReturns())}  -- t2 = {1}

-- 实用例子
local s = "Hello, world!"
local firstComma = (string.find(s, ",")) -- 只返回第一个分割字符串
print(firstComma)  -- 输出: 6
```

**特性：<GN>变长参数</GN>**
简单来说，变长参数就是`...`

``` lua
-- 加法函数
function add(...)
  local s = 0
  for i,v in ipairs{...} do
    s = s + v
  end
  return s
end

print(add(3,4,10,25,12)) -- 54
```

**<BL>问题：为什么可以是`ipairs{...}`，不应该是`ipairs(table)`吗</BL>**
<BL>在前面我们提到过如果只有一个参数是可以省略括号的，那么本质上这其实是`ipairs({...})`，也就是<b>构建了一个table传入</b>，那么我们也能发现：**<VT>`ipairs`其实是一个函数</VT>**</BL>

**两种逻辑：**

- `local a, b = ...`---多返回值
- `{...}`---多返回值组成table

**<GN>特殊函数：`unpack()`</GN>**
简单来说，该函数就是用于**table转多返回值的**
<YL><b>举个例子</b>的话就是：`string.find()`需要多参数，但我手上可能有一个table，使用`unpack()`即可转换为多参数，可能有`string.find(unpack({"hello", "ll"}))`</YL>
虽然`unpack()`由C实现，但在**Lua**中我们也可以**实现**：

``` lua
-- 大致就是：
-- 我们使用unpack(t)，然后取i再递归看看i+1有没有
function unpack(t, i)
    i = i or 1
    if t[i] then
        return t[i], unpack(t, i+1)
    end
end
```

# 3.库

常用的库有：
- 数学库math
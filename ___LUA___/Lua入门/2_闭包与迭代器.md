**<center><BBBG>2_闭包</BBBG></center>**

<!-- TOC -->

- [1.前置基础](#1前置基础)
- [2.闭包基础](#2闭包基础)
- [3.迭代器与泛型for](#3迭代器与泛型for)

<!-- /TOC -->

# 1.前置基础

由于函数是<B><GN>第一类值</GN></B>，所以<B><VT>数字和字符串是具有相同权力</VT></B>的
这也意味着：<B><VT>函数可以存储到变量/table中，可以作为实参传入函数，也可以作为返回值</VT></B>

由于Lua函数<B><VT>可以嵌套，且内部函数可以访问外部变量</VT></B>，所以可以应用<B><GN>函数式编程</GN></B>

需要注意的是：<B><DRD>函数是匿名的</DRD></B>
一般情况下我们会这么写函数：
``function foo(x) return 2*x end``
上述写法其实是一种**语法糖**，事实上这等价于：
``foo = function(x) return 2*x end``
即**foo是一个变量，存储了一个匿名函数**
所以说：<VT>`function() ... end`其实是类似于`{}`(table构造式)的函数构造式</VT>

<B><VT>以另一个函数为参数的函数</VT></B>被称为<B><GN>高阶函数</GN></B>
可以有：``table.sort(network, function(a,b) return (a.name > b.name) end)`` <VT>此时sort函数高阶函数</VT>

在table中，由于函数是第一类值，我们可以将其定义为**局部函数**，有2种方法：

``` lua
-- 方法1
local fact -- 前向声明
fact = function(n)
  if n == 0 then return 1
  else return n * fact(n-1) -- 虽然此时fact()还是没有定义完成，但是至少指代的是local的fact，解释型语言自然能知道fact是什么
  end
end

-- 方法2
local function fact(n)
  if n == 0 then return 1
  else return n * fact(n-1)
  end
end
```

**<DRD>要注意的是：这里`local fact`必须提前声明，否则递归的`fact()`只能去寻找全局的fact，全局的话不存在也不正确</DRD>**
**<BL>问题：为什么方法2可以<BL>**
<BL>方法2是一种语法糖，这等价于方法1</BL>

**<VT>Tip：对于间接递归函数(由调用其它函数调回自己的递归方式)必须使用方法1，即明确前向声明</VT>**
**<BL>问题：为什么<BL>**
如以下最简单的间接递归函数例子：

``` lua
local f, g

function g()
    -- ...
    f()
    -- ...
end
function f()
    -- ...
    g()
    -- ...
end
```

在这里如果是前向声明那一定是可以的，但是如果使用语法糖，其实就变成了：

``` lua
local g
function g()
    f()
end
local f
function f()
    g()
end
```

那么在g函数声明的时候f变量并没有赋值，当然是不可行的
**<DRD>所以：尽量不要使用语法糖形式，否则就需要仔细检查一下</DRD>**

# 2.闭包基础

<B><GN>闭包</GN></B>指的是：<B><VT>一个函数加上该函数所需访问的所有upvalue</VT></B>
<B><GN>闭包函数</GN></B>指的是：<B><VT>捕获到外部变量的那个函数，即内层函数</VT></B>
<B><GN>upvalue</GN></B>指的是：<B><VT>被捕获到的外部变量</VT></B>

**例1：**
``` lua
-- Tip：比较函数比的是table的value
names = {"Peter", "Paul", "Mary"}
grades = {Mary = 10, Paul = 7, Peter = 8}
table.sort(names, function (n1, n2)
    return grades[n1] > grades[n2] -- 比较年纪
end)

-- 写成函数
function sortbygrade(names, grades)
    table.sort(names, function (n1, n2)
        return grades[n1] > grades[n2] -- 比较年纪
    end)
end
```

在这里有局部变量`names` `grades`，它们都被`table.sort()`内部函数所使用，由于`grades`在匿名函数中，它被称为<B><GN>非局部变量(non-local varibale)，即上值(upvalue)</GN></B>
**<BL>问题：为什么`grades`是upvalue而`name`不是</BL>**
<BL>以C#的说法的话，其实就是闭包存在于lambda表达式与局部函数(C#的)
在Lua的话虽然概念不同，但其实和C#完全一致，只有2种形式，即<B>匿名函数与内部函数</B>
那么names并不符合，当然不是upvalue</BL>

<B><DRD>注意：同一个函数可以产生多个闭包</DRD></B>
**例2：尾递归**

``` lua
function newCounter()
    local i = 0
    return function()
        i = i + 1
        return i
    end
end

c1 = newCounter()
print(c1()) -- 1
print(c1()) -- 2

c2 = newCounter()
print(c2()) -- 1
print(c1()) -- 3
print(c2()) -- 2
```

c1和c2的两次函数创建了不同的局部变量i，c1和c2当然是**不同的闭包**
此处使用到了<B><GN>尾调用</GN></B>---<B><VT>函数是另一个函数的最后一个动作</VT></B>
Lua支持<B><GN>尾调用消除</GN></B>，所以说：<B><VT>解释器会对尾调用优化，不会耗费任何栈空间</VT></B>
**<DRD>注意：尾递归必须是最后一个动作，如`return g(x)+1`由于加法操作，并不是最后一个动作，需注意</DRD>**
尾递归的一种应用：<B><YL>状态机<YL></B>

``` lua
-- 每个房间都如此，那么虽然会在房间穿梭，
-- 但是由于发生的都是尾递归，所以尾递归消除的优化避免了栈的无限深入
function room1 ()
    local move = io.read()
    if move == "south" then 
        return room3()
    elseif move == "east" then 
        return room2()
    else
        print("invalid move")
        return room1() -- stay in the same room
    end
end
```

**例3：用于<GN>回调函数</GN>**
``` lua
-- GUI中，有一个十进制计算机，一下为按钮的定义
-- 在这里，匿名函数能够捕获到digit
function digitButton(digit)
    return Button{label = tostring(digit),
                  action = function()
                              add_to_display(digit)
                            end
                  }
end
```

**例4：重定义函数**

``` lua
-- oldSin()即math.sin()被完全覆盖了，所以此时：
-- · math.sin()被覆盖为新的算法，我们只能调用到新的math.sin()
-- · 老的math.sin()已不复存在，我们只能通过新的math.sin()闭包调用oldSin访问到
-- 总的来说：是因为oldSin被包裹在了一个块中，那么出块后oldSin定义域一过就访问不了了，而math.sin是全局的，直接就被覆盖了
do
  local oldSin = math.sin
  local k = math.pi/180
  math.sin = function (x)
    return oldSin(x*k)
  end
end
```

**例5：安全的运行时环境**

``` lua
-- 在调用io.open()前先进行权限检查，通过才调用
do
    local oldOpen = io.open
    local access_OK = function(filename, mode)
        -- 检查访问权限
    end
    io.open = function(filename, mode)
        if access_OK(filename, mode) then
            return oldOpen(filename, mode)
        else
            return nil, "access denied"
        end
    end
end
```

**例6：函数式编程**

``` lua
function disk(cx, cy, r)
    return function(x, y)
        return (x - cx)^2 + (y - cy)^2 <= r^2
    end
end
  
function rect(left, right, bottom, up)
    return function(x, y)
        return left <= x and x <= right and bottom <= y and y <= up
    end
end
  
function complement(r)
    return function(x, y)
        return not r(x, y)
    end
end
  
function union(r1, r2)
    return function(x, y)
        return r1(x, y) or r2(x, y)
    end
end
  
function intersection(r1, r2)
    return function(x, y)
        return r1(x, y) and r2(x, y)
    end
end
  
function difference(r1, r2)
    return function(x, y)
        return r1(x, y) and not r2(x, y)
    end
end

function translate(r, dx, dy)
    return function(x, y)
        return r(x - dx, y - dy)
    end
end

-- 函数用于将区域函数r绘制为ASCII艺术
-- M是宽度，N是高度
function plot(r, M, N)
  io.write("P1\n", M, " ", N, "\n")  -- 写入PBM格式的文件头
  
  for i = 1, N do                    -- 对于每一行
    local y = (N - i*2)/N            -- 计算y坐标
    
    for j = 1, M do                  -- 对于每一列
      local x = (j*2 - M)/M          -- 计算x坐标
      
      io.write(r(x, y) and "1" or "0")  -- 如果点在区域内写1，否则写0
    end
    
    io.write("\n")                   -- 行结束换行
  end
end

c1 = disk(0,0,1)
plot(difference(c1, translate(c1, 0.3, 0)), 500, 500)
```

# 3.迭代器与泛型for

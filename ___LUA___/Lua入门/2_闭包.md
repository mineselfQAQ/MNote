**<center><BBBG>2_闭包</BBBG></center>**

<!-- TOC -->

- [前置基础](#前置基础)
- [闭包基础](#闭包基础)

<!-- /TOC -->

# 前置基础

由于函数是<B><GN>第一类值</GN></B>，所以<B><VT>数字和字符串是具有相同权力</VT></B>的
这也意味着：<B><VT>函数可以存储到变量/table中，可以作为实参传入函数，也可以作为返回值</VT></B>

由于Lua函数<B><VT>可以嵌套，且内部函数可以访问外部变量</VT></B>，所以可以应用<B><GN>函数式编程</GN></B>

需要注意的是：<B><DRD>函数是匿名的</DRD></B>
一般情况下我们会这么写函数：
``function foo(x) return 2*x end``
上述写法其实是一种**语法糖**，事实上这等价于：
``foo = function(x) return 2*x end``
即**foo是一个变量，存储了一个匿名函数**
所以说：<VT>`function() ... end`其实是类似于`{}`(table构造式)的函数构造式</VT>

<B><VT>以另一个函数为参数的函数</VT></B>被称为<B><GN>高阶函数</GN></B>
可以有：``table.sort(network, function(a,b) return (a.name > b.name) end)`` <VT>此时sort函数高阶函数</VT>

在table中，由于函数是第一类值，我们可以将其定义为**局部函数**，有2种方法：

``` lua
-- 方法1
local fact -- 前向声明
fact = function(n)
  if n == 0 then return 1
  else return n * fact(n-1) -- 虽然此时fact()还是没有定义完成，但是至少指代的是local的fact，解释型语言自然能知道fact是什么
  end
end

-- 方法2
local function fact(n)
  if n == 0 then return 1
  else return n * fact(n-1)
  end
end
```

**<DRD>要注意的是：这里`local fact`必须提前声明，否则递归的`fact()`只能去寻找全局的fact，全局的话不存在也不正确</DRD>**
**<BL>问题：为什么方法2可以<BL>**
<BL>方法2是一种语法糖，这等价于方法1</BL>

**<VT>Tip：对于间接递归函数(由调用其它函数调回自己的递归方式)必须使用方法1，即明确前向声明</VT>**
**<BL>问题：为什么<BL>**
如以下最简单的间接递归函数例子：

``` lua
local f, g

function g()
    -- ...
    f()
    -- ...
end
function f()
    -- ...
    g()
    -- ...
end
```

在这里如果是前向声明那一定是可以的，但是如果使用语法糖，其实就变成了：

``` lua
local g
function g()
    f()
end
local f
function f()
    g()
end
```

那么在g函数声明的时候f变量并没有赋值，当然是不可行的
**<DRD>所以：尽量不要使用语法糖形式，否则就需要仔细检查一下</DRD>**

# 闭包基础

<B><GN>闭包</GN></B>指的是：<B><VT>一个函数加上该函数所需访问的所有upvalue</VT></B>
<B><GN>闭包函数</GN></B>指的是：<B><VT>捕获到外部变量的那个函数，即内层函数</VT></B>
<B><GN>upvalue</GN></B>指的是：<B><VT>被捕获到的外部变量</VT></B>

**例1：**
``` lua
-- Tip：比较函数比的是table的value
names = {"Peter", "Paul", "Mary"}
grades = {Mary = 10, Paul = 7, Peter = 8}
table.sort(names, function (n1, n2)
    return grades[n1] > grades[n2] -- 比较年纪
end)

-- 写成函数
function sortbygrade(names, grades)
    table.sort(names, function (n1, n2)
        return grades[n1] > grades[n2] -- 比较年纪
    end)
end
```

在这里有局部变量`names` `grades`，它们都被`table.sort()`内部函数所使用，由于`grades`在匿名函数中，它被称为<B><GN>非局部变量(non-local varibale)，即上值(upvalue)</GN></B>
**<BL>问题：为什么`grades`是upvalue而`name`不是</BL>**
<BL>以C#的说法的话，其实就是闭包存在于lambda表达式与局部函数(C#的)
在Lua的话虽然概念不同，但其实和C#完全一致，只有2种形式，即<B>匿名函数与内部函数</B>
那么names并不符合，当然不是upvalue</BL>

<B><DRD>注意：同一个函数可以产生多个闭包</DRD></B>
**例2：**
<div style="height: -10px;"></div>

``` lua
function newCounter()
    local i = 0
    return function()
        i = i + 1
        return i
    end
end

c1 = newCounter()
print(c1()) -- 1
print(c1()) -- 2

c2 = newCounter()
print(c2()) -- 1
print(c1()) -- 3
print(c2()) -- 2
```

c1和c2的两次函数创建了不同的局部变量i，c1和c2当然是**不同的闭包**

**例3：用于<GN>回调函数</GN>**
``` lua
-- GUI中，有一个十进制计算机，一下为按钮的定义
-- 在这里，匿名函数能够捕获到digit
function digitButton(digit)
    return Button{label = tostring(digit),
                  action = function()
                              add_to_display(digit)
                            end
                  }
end
```
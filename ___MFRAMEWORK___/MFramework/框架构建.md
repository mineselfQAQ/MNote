**<center><BBBG>MFramework框架构建</BBBG></center>**

<!-- TOC -->

- [前期分析](#%E5%89%8D%E6%9C%9F%E5%88%86%E6%9E%90)
    - [抉择点](#%E6%8A%89%E6%8B%A9%E7%82%B9)
        - [程序集](#%E7%A8%8B%E5%BA%8F%E9%9B%86)
            - [情况](#%E6%83%85%E5%86%B5)
            - [分析](#%E5%88%86%E6%9E%90)
            - [参考](#%E5%8F%82%E8%80%83)
            - [结论](#%E7%BB%93%E8%AE%BA)
        - [IOC](#ioc)
            - [情况](#%E6%83%85%E5%86%B5)
            - [分析](#%E5%88%86%E6%9E%90)
            - [参考](#%E5%8F%82%E8%80%83)
            - [结论](#%E7%BB%93%E8%AE%BA)
        - [框架内核](#%E6%A1%86%E6%9E%B6%E5%86%85%E6%A0%B8)
            - [分析](#%E5%88%86%E6%9E%90)
            - [参考](#%E5%8F%82%E8%80%83)
            - [结论](#%E7%BB%93%E8%AE%BA)
        - [分层架构](#%E5%88%86%E5%B1%82%E6%9E%B6%E6%9E%84)
            - [结论](#%E7%BB%93%E8%AE%BA)
- [框架搭建](#%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA)
    - [Git](#git)
    - [框架](#%E6%A1%86%E6%9E%B6)
        - [v0.01](#v001)
            - [流程简述](#%E6%B5%81%E7%A8%8B%E7%AE%80%E8%BF%B0)
            - [MTracker](#mtracker)

<!-- /TOC -->

# 前期分析

究竟要搭建一个怎么样的框架是一个非常困难的选择，简单也好，复杂也好，使用的工具也好，各个框架的实现各不相同
所以需要好好考虑各个**抉择点**

## 抉择点

那么先来讲述一下具有**抉择的内容**：

- **程序集**
  程序集即dll，一般代码在Unity会编译为一个dll，但我们也能进行拆分，如何拆分是需要考虑的
- **IOC**
  ICO是一种方便的技术，对扩展性有极大的好处，但是到底用不用，需要什么程度的IOC也是值得思考的
- **框架内核**
- **分层架构**

<BR>

在下面的分析中，会**参考**以下几种我分析过的**框架**：

- Unity框架
  - CatLib
  - QFramework
  - LoxodonFramework
  - MyFramework
  - MyUnityFramework
  - UnityGameFramework
- 其它
  - PureMVC
  - MicrosoftDI

### 程序集

#### 情况

简单来说有以下几种情况：　<VT>由简单到复杂</VT>

- 1.直接写
- 2.用asmdef分类
- **3.在外部编译dll，Unity中扩展Unity版本**---<B><VT>选择</VT></B>

#### 分析

可以看到，在前面几种情况中，桥接不一定发生，直接全写Unity里就行了
显而易见的是：<B><VT>越脱离Unity，可扩展性/复用性也就越高</VT></B>
同样的：<B><VT>编译为dll后改动就比较麻烦了</VT></B>
<B><BL>什么能脱离Unity，怎么脱离Unity，需要脱离多少</BL></B>是需要注意的问题：

- 与Unity无关的内容必然是可以脱离的
- MonoBehaviour本身不能脱离，但可通过接口并实现的方式在外部dll中完成核心逻辑，只需桥接到Unity中即可
- UnityAPI本身只应该在Unity中使用，但也可由包装后依赖注入的方式在外部dll中使用

#### 参考

各种框架情况：

- **CatLib：情况3**
  dll部分：`CatLib.Core.dll`
  Unity部分：`CatLib.Unity.asmdef`/`CatLib.Editor.asmdef`
- **QFramework：情况2**
  框架部分为`QFramework.asmdef`，其余内容在相应Kit的asmdef中
- **LoxodonFramework：情况2**
  分为`Loxodon.Framework.asmdef`/`Loxodon.Framework.Editor.asmdef`/`Loxodon.Log.asmdef`
- **MyFramework：情况2**
  拆分为Frame部分以及业务部分，同时有Editor以及HotFix
- **MyUnityFramework：情况1**
- **UnityGameFramework：情况3**
  dll部分：`GameFramework.dll`
  Unity部分：`UnityGameFramework.Runtime.asmdef`/`UnityGameFramework.Editor.asmdef`

<BR>

可以看到大部分框架都会选择进行分类，分类必然是一件好事，但是到底要不要封装成dll就需要考虑了

#### 结论

个人认为dll的封装是有必要的，毕竟我的想法是：**脱离Unity，在其它C#语言引擎中几乎可以即拿即用**

**思路**为：

- 框架底层单独打一个dll，这部分成型后尽量保证不改动
- 功能类也打dll，Unity编写适配脚本
  但在制作初期用asmdef代替，成型后改为dll，编写自动构建脚本快速生成dll用于修改

以下是一些**注意点**：

- **<VT>外部dll需要基于Standard2.1版本(新一点，但也不算新)</VT>**

<BR>

### IOC

#### 情况

- 1.不使用
- **2.使用DI基础版**---<B><VT>选择</VT></B>
- 3.使用DI完整版
- 4.使用SL(ServiceLocator)

#### 分析

SL与DI都是用于实现IOC的一种方式
**<VT>IOC是一种设计原则，即将程序的控制权从应用程序代码转移到外部容器或框架</VT>**
简单分析一下不同实现的区别：

- 不使用IOC：
  `_emailService = new SmtpEmailService()`
  每次都是一个新的
- SL：服务定位器模式，这种实现方式比较简单，简单来说就是<B><VT>需要时提供</VT></B>：
  `container.Register<IEmailService>(new SmtpEmailService());`
  `_emailService = container.Get<IEmailService>()`
  可以说其实更像是一种**管理方式**：<VT>需要该接口，我给你已经缓存的</VT>
- DI：依赖注入，核心在**注入**二字
  `container.Bind<IEmailService, SmtpEmailService>()`
  `_emailService = container.Make<IEmailService>()`

**<BL>问题：DI比SL好在哪</BL>**
<B><VT>DI被动接收，SL手动获取</VT></B>
<BL>两者看起来区别真的不大，但是仔细考虑的话<B>在更深层次DI是更优的</B>：

- <BL>SL本身就是一种依赖，Get时才会获取，但通过反射的方式可解决</BL>
- <BL>最简SL无法完成不同实际接口的获取，但通过多容器/域之类的方式可解决</BL>
- <BL>SL具有延迟性，需要才创建</BL>

<BL>由此会发现：</BL>
**<VT>DI其实就是最佳实现的SL</VT>**

#### 参考

首先简述一下使用到DI概念的框架：

- **MicrosoftDI** 　<VT>复杂DI</VT>
  显然，这是一个用于提供DI功能的纯DI框架，这包含了DI的方方面面
  就简单来说，重点为：支持各种形式的注入以及域控制
- **CatLib** 　<VT>复杂DI</VT>
  在其dll的CatLib.Container下，总的来说是比较复杂的，但核心非常简单：

  - `Bind()`：绑定
  - `Make()`：解析
  
  知道这两个函数即可使用，即在Framework派生类下调用`App.Bind()`/`App.Make()`
- **QFramework**　<VT>简单SL</VT>
  在核心QFramework.cs中，提供了一个IOCContainer类，代码相当简单，其实就是一个key为Type，value为object的字典，使用`container.Register()`/`container.Get()`即可
- **LoxodonFramework**　<VT>较复杂SL</VT>
  用于服务获取，相比QFramework，这里的会更细致一点


<BR>

可以看到的是大部分Unity框架并未提供IOC这一项功能<VT>(也许是像QFramework一样太简单了没看见hhh)</VT>

#### 结论

可以看到QFramework的SL基本能够满足需求而且特别简单，而其余两种(MicrosoftDI/CatLib)的DI功能上更加健全，这也需要一定的性能去处理
我所想要的可能**接近于LoxodonFramework的实现**

<BR>

### 框架内核

#### 分析

**框架内核**指的就是框架的最底层，无关模块功能
两者结合来看，简单来说就是<B><VT>如何启动与管理项目</VT></B>

想必每一个框架都会选择自己的方式，而且框架的涉及点(UI框架/底层框架/模块)不同，很难给出同一标准参考
以下是**考量方式**：

- 入口：唯一入口/多入口
- 模块加载：单例/IOC
- 模块组织

#### 参考

- **LoxodonFramework(纯UI框架)**
  该框架可以说是UI框架，整体上来说仅是界面启动流程，具有的功能类其实也是为UI服务的
  - 入口：业务入口，需手动编写初始化流程，进行IOC注册，最终由界面加载流程完成初始界面的显示
  - 模块加载/模块组织：
    - 功能类：独立
    - 模块：通过IOC(SL)注册解析
  
    既然是IOC，那么注册与获取的顺序的顺序就不重要了，仅需在注册时确定依赖关系
- **QFramework(底层框架)**
  该框架相当底层，仅用千行提供了基础流程，本质上其实还是一种UI框架(MVC)
  该框架的核心是在制定规范，也就是：Architecture/Model/Controller/Command/Event/Utility/System/Query
  每种规则都会有一定的限制，也会按流程初始化
  - 入口：MonoBehaviour+IController类，通常会由一个Command开启流程
  - 模块加载/模块组织：额外作为Kit提供
    - 功能类：独立
    - 模块：
      - 底层模块(CoreKit)：独立，每个子Kit不应该互相依赖，内部会通过IOC(SL)进行提前准备依赖
      - 扩展模块(如UIKit)：依赖于CoreKit，但仅依赖于此(不考虑QFramework核心)
  
    Kit如果是模块，具有独立流程，各Kit间无关
- **CatLib(底层框架)**
  该框架相当底层，核心就是一个Application，IApplication+IContainer就是全部
  - 入口：唯一入口Main，是作者扩展完毕的业务入口，其中包含一定的初始化流程
  - 模块加载/模块组织：由Bootstraps启动流程+IOC容器+ServiceProvider协作完成
- **MyUnityFramework(功能型框架)**
  该框架更偏向于模块功能，底层构建算不上完善，整体就是Manager叠加
  - 入口：
    - 业务入口：IApplicationStatus派生状态，需在ApplicationManager中选择状态
    - 底层入口：双入口，即ApplicationManager+UIManager
  - 模块加载/模块组织：由Manager组成，核心ApplicationManager进行Manager初始化的顺序控制，也就是说也许调整顺序会导致报错出现
- **UnityGameFramework(功能型框架)**
  该框架可以说是组件式的，项目中每一个模块都被写成了一个GameFrameworkComponent，所有模块的实现都被写在了dll中，Component只是一层Unity封装
  - 入口：GameEntry作为唯一入口，但本质上是由多个Component(MonoBehaviour)注册得来，更确切地来说应该是一模块一入口，底层有类似的GameFrameworkEntry唯一入口
  - 模块加载/模块组织：每个模块都是一个Component，在模块底层存在引用，Start需通过Set方法在Unity层注入(最常见的是`SetResourceManager()`)，Update/Shutdown则通过Priority排序，以保证不报错顺序执行
- **MyFramework(底层功能型框架)**
  该框架整体是略显复杂的，因为拆分出了基础/不可热更/可热更代码，但本质上没有区别
  - 入口：业务类GameEntryDerived作为唯一入口，核心就是创建mFrameworkAOT/mFrameworkHotFix并管理了它们的生命周期
  - 模块加载/模块组织：先mFrameworkAOT(底层一点)后mFrameworkHotFix，两者都会对System需要进行实例化注册，也就是有序的，其中mFrameworkHotFix是由`mGameSceneManager.enterScene<LaunchScene>()`开启的，整体流程略显复杂

可以发现以上几种框架使用的框架内核形态各异，下面用一句话总结一下：

- **LoxodonFramework**：提供IOC，需自行进行组织
- **QFramework**：严格接口规定，如有依赖会通过IOC(SL)处理，但各模块间几乎独立，需要时直接获取即可
- **CatLib**：提供更完善的IOC，IServiceProvider可进行对Container的封装，并由Bootstraps启动流程完成初始化流程
- **MyUnityFramework**：由ApplicationManager进行对其它Manager的初始化
- **UnityGameFramework**：组件自行进行初始化，并交由Entry管理(底层/业务层都是这样)
- **MyFramework**：由GameEntryDerived进行初始化流程并初始化System

可以发现大致能分为4种：

- **唯一入口**：由一个管理模块对所有需要的模块进行初始化
  - **IOC**：唯一入口的一种特例，可能有也可能没有基础流程，但核心都是由IOC完成注册，由于DI的特性(SL不行)注册顺序无关
- **组件式**：每个模块对应一个MonoBehaviour脚本进行初始化
- **无关联**：模块间没有关联，流程上自然是完全自由的

#### 结论

显然，这4种情况中**IOC**是最合适的，本质上来说IOC就是唯一入口的一种特例，但DI的特性极大地增加了初始化的流畅度

### 分层架构

**分层架构**本质上指的就是代码结构
这里就不过多分析每种框架的分层架构，毕竟框架也不是完整的项无法得知具体情况下的分层架构

#### 结论

这里就参考**LoxodonFramework**在文档中对分层架构的描述：
<B><VT>基于DDD</VT></B>实现<B><VT>整体代码层面</VT></B>的分层架构(每一层的实现可继续封层)，分为：

- 表现层
  - View层
  - ViewModel层
- 服务层
  - Service
- 领域层(贫血模型)
  - Entity
  - Value Object
  - Repository
- 基础层
  - 框架
  - 模块
  - 辅助类

# 框架搭建

根据上述前期分析，我们可以了解到细节大概是怎么样的

## Git

在搭建前，先考虑一下**svn的目录层级**
**最基础的目录**如下所示：

- MFramework
  - branches--功能分支
  - tags--版本分支
  - trunk--主干

搭建中存在**问题**：

- **资源问题**
  资源最有可能会放在Resources文件夹中，但放在外部(热更流程)也同样合理
  同时由于有branches/trunk，不应该在每个分支中都填充一次
  **<VT>决定：在trunk下创建Resources目录，如某branch制作的特性具有资源，则在branch下也创建Resource目录，完成后对应merge即可</VT>**
- **dll问题**
  项目分为dll与asmdef，考虑到dll制作期的不可测试性，前期会用asmdef代替，这样的话项目内部结构其实是混乱的(有本来的asmdef，又有dll的asmdef，必然也会有真正的dll)
  **<VT>解释：这不是问题，trunk中的混乱是可接受的，只考虑trunk，必然是一步一步转向最终构建，考虑branches开发，功能的开发是引用于trunk当前版本的(使用`Branch/tag...`功能进行复制引用)，也就是说主干决定了分支是否混乱，但无论是否混乱，都是能正常运行的(只要主干正常)</VT>**

也就是说**trunk的结构**是我们所需要关心的(branches/tags是跟着trunk走的)，有：

- trunk
  - Project---Unity项目
  - Resources---资源(可由服务器替代，此时就作为源文件存在)
  - DLLProject---dll项目
  - 以下是可能添加内容：
  - Server---服务器
  - Tools---工具链
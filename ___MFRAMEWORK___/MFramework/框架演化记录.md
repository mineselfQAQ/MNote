**<center><BBBG>MFramework框架演化记录</BBBG></center>**

<!-- TOC -->

- [v0.1.0](#v010)
  - [简述](#简述)
  - [TODO](#todo)
- [v0.1.1](#v011)
  - [简述](#简述-1)

<!-- /TOC -->

<BR>

**版本号规定：**
`major.minor.patch` 即 `主.辅.补丁`

# v0.1.0

## 简述

以下为第一版情况的设计：
整体来说主要借鉴了**CatLib**的设计：

- 由于框架核心需要放在dll中，所以必然会有一层包装
  - dll：MFrameworkCore
  - Unity：MEntry
  
  具体情况如下：
  MFrameworkCore在Unity中派生成MCore，MEntry有一基类MEntryBase，MEntryBase为框架Unity层构建，需自行派生为MEntry实现内置功能
- 框架功能有：
  - 生命周期(提供事件回调)
  - IOC(目前为SL实现)

<BR>

以下是目前版本的**框架流程**，由MEntryBase制定：

``` csharp
/// <summary>
/// 框架的唯一入口，一个项目仅应该存在一个MEntry
/// MEntry本质上是MFramework的一层封装，操作由MFramework提供
/// </summary>
public abstract class MEntryBase : MonoBehaviour
{
    protected MCore _core;
    
    protected void Awake()
    {
        _core = (MCore)CreateCore();
        // 事件注册
        _core.OnStart(OnStart);
        _core.OnBootstrapping(OnBootstrapping);
        _core.OnBootstrapped(OnBootstrapped);
        _core.OnInitializing(OnInitializing);
        _core.OnInitialized(OnInitialized);
        _core.OnShuttingDown(OnShuttingDown);
        _core.OnShutDown(OnShutDown);
        // 流程项注册
        _core.AddBootstrap(new InternalBootstrap(_core));
        _core.AddBootstrap(GetUserBootstrap());
        _core.AddShutdown(new InternalShutDown());
        _core.AddShutdown(GetUserShutDown());
        
        // 启动
        _core.Bootstrap();
    }

    protected void Start()
    {
        _core.Initialize();
    }

    protected virtual void OnApplicationQuit()
    {
        _core.Shutdown();
    }

    protected virtual MFrameworkCore CreateCore()
    {
        return new MCore();
    }
    
    protected abstract IBootstrap GetUserBootstrap();
    protected abstract IShutdown GetUserShutDown();
    
    protected virtual void OnStart() { }
    protected virtual void OnBootstrapping() { }
    protected virtual void OnBootstrapped() { }
    protected virtual void OnInitializing() { }
    protected virtual void OnInitialized() { }
    protected virtual void OnShuttingDown() { }
    protected virtual void OnShutDown() { }
}
```

可以看到其实就是3个阶段函数：

- `_core.Bootstrap()`：启动，核心用于注册ServiceProvider
  - ServiceProvider：内部进行IOC注册
- `_core.Initialize()`：ServiceProvider的初始化操作
- `_core.Shutdown()`

在MFrameworkCore中，具体实现如下：

``` csharp
public virtual void Bootstrap()
{
    _tracker.Next();
    {
        foreach (var bootstrap in _bootstraps)
        {
            bootstrap.Bootstrap();
        }
    }
    _tracker.Next();
}

public virtual void Initialize()
{
    _tracker.Next();
    {
        foreach (var serviceProvider in _loadedServiceProviders)
        {
            serviceProvider.Initialize();
        }
    }
    _tracker.Next();
}

public virtual void Shutdown()
{
    _tracker.Next();
    {
        foreach (var serviceProvider in _loadedServiceProviders)
        {
            serviceProvider.Shutdown();
            serviceProvider.Unregister();
        }
        _loadedServiceProviders.Clear();

        foreach (var shutdown in _shutdowns)
        {
            shutdown.Shutdown();
        }
    }
    _tracker.Next();
}
```

流程内容需注册，即：

``` csharp
public virtual void Register(IServiceProvider serviceProvider)
{
    serviceProvider.Register();
    _loadedServiceProviders.Add(serviceProvider);
}

public void AddBootstrap(IBootstrap bootstrap)
{
    _bootstraps.Add(bootstrap);
}

public void AddShutdown(IShutdown shutdown)
{
    _shutdowns.Add(shutdown);
}
```

其中`Register()`比较特殊，被隐含在Bootstrap流程中
更正确地来说：<B><VT>在`Bootstrap()`中，应该完成ServiceProvider的注册操作</VT></B>
UserBootstrap就是一种实现：

``` csharp
public class UserBootstrap : IBootstrap
{
    private readonly MFrameworkCore _core;
    private readonly IServiceProvider[] _serviceProviders;
    
    public UserBootstrap(MFrameworkCore core, IServiceProvider[] serviceProviders)
    {
        _core = core;
        _serviceProviders = serviceProviders;
    }
    
    public void Bootstrap()
    {
        foreach (IServiceProvider serviceProvider in _serviceProviders)
        {
            // 提供SP，统一进行注册
            _core.Register(serviceProvider);
        }
    }
}
```

在MFrameworkCore中，提供了一种<B><GN>MTracker</GN></B>的功能，为<B><VT>阶段处理器</VT></B>
MTracker的核心为`Next()`：

``` csharp
public void Next()
{
    if (_curId > _maxId) return;
    
    if (_phaseTackers.TryGetValue(_curId, out var preTracker))
    {
        preTracker.Complete();
    }

    int preId = _curId;
    _curId++;

    if (_curId == _maxId)
    {
        EndTime = DateTime.Now;
    }

    var curTracker = new PhaseTracker(_curId, _phaseInfos[_curId].Name);
    _phaseTackers[_curId] = curTracker;

    if (preId == 0)
    {
        OnPhaseChanged(_curId, curTracker);
    }
    else
    {
        OnPhaseChanged(preId, _curId, preTracker, curTracker);
    }
}
```

简单来说就是：<VT>Complete上一个PhaseTracker，创建新的PhaseTracker</VT>
这里值得注意的应该就是<B>事件回调`OnPhaseChanged()`</B>了：
这里是由<B>事件系统<GN>EventBus</GN></B>完成，此处提供的操作就是：

``` csharp
protected virtual void AddChangedEvent(Action<int, PhaseTracker> action)
{
    _eventBus.Register<PhaseChangedEvent>((e) =>
    {
        action(e.CurId, e.CurTracker);
    });
}

protected virtual void AddChangedEvent(Action<PhaseChangedEvent> action)
{
    _eventBus.Register<PhaseChangedEvent>(action);
}

protected virtual void OnPhaseChanged(int curId, PhaseTracker curTracker)
{
    _eventBus.Publish<PhaseChangedEvent>(new PhaseChangedEvent(
        -1, curId, null, curTracker));
}

protected virtual void OnPhaseChanged(int preId, int curId, PhaseTracker preTracker, PhaseTracker curTracker)
{
    _eventBus.Publish<PhaseChangedEvent>(new PhaseChangedEvent(
        preId, curId, preTracker, curTracker));
}
```

`Next()`提供了事件的触发，而`RegisterPhase()`提供了事件的添加：

``` csharp
public void RegisterPhase(string name, Action action)
{
    ++_registerId;
    ++_maxId;
    int registerId = _registerId; // 避免闭包
    _phaseInfos.Add(_registerId, new PhaseInfo(_registerId, name));

    if (action != null)
    {
        AddChangedEvent((id, tracker) =>
        {
            if (id == registerId)
            {
                action?.Invoke();
            }
        });
    }
}
```

## TODO

**1**
目前很奇怪的点在于：`RegisterPhase()`会用于添加事件，为了让MEntry进行override，需要做的是：MFrameworkCore提供注册，在MEntryBase中调用，同时提供virtual函数

``` csharp
// MFrameworkCore
public void OnStart(Action action) => _onStart = action;

protected virtual void OnStartInternal()
{
    _onStart?.Invoke();
}

// MEntryBase
protected void Awake()
{
    // ...
    _core.OnStart(OnStart);
    // ...
}

protected virtual void OnStart() { } // 最终override即可
```

这样总感觉传递的太复杂了
**2**
除此以外，目前各个类并没有完整写完，都可以添加一些额外的辅助函数
**3**
IOC待提升

<BR>

# v0.1.1

**MTracker**进行了一次提升

## 简述

MTracker改进了很多，原来的MTracker使用的是继承的方式，由于扩展内容有多个，容易过度横向扩展，所以改成了**组合模式**
简单来说：

- MTracker：核心类，作为单个追踪器存在
- MTrackerFactory：静态类，可通过`CreateTracker()`创建不同形态的MTracker
- MAutoTracker：自动化版MTracker扩展，用IDisposable实现，由工厂包装MTracker得来

<BR>

``` csharp
using System;
using System.Collections.Generic;

namespace MFramework.Core
{
    public interface IMTracker
    {
        int Id { get; }
        string Name { get; }
        
        DateTime StartTime { get; }
        DateTime EndTime { get; }
        TimeSpan Duration { get; }
        
        bool IsStarted { get; }
        bool IsRunning { get; }
        bool IsCompleted { get; }
        
        void Start();
        void Stop();
    }
    
    public class MTracker : IMTracker
    {
        private int _id;
        private string _name;
        private bool _isStarted;
        private bool _isCompleted;

        private readonly ITrackerEventPublisher _publisher;
        private readonly ITrackerCollector _collector;

        public int Id
        {
            get { return _id; }
        }

        public string Name
        {
            get { return _name; }
        }
        
        public bool IsStarted
        {
            get { return _isStarted; }
        }
        
        public bool IsCompleted
        {
            get { return _isCompleted; }
        }
        
        public bool IsRunning => _isStarted && !_isCompleted;
        
        public DateTime StartTime { get; private set; }
        public DateTime EndTime { get; private set; }

        public TimeSpan Duration => _isCompleted ? EndTime - StartTime : TimeSpan.Zero;
        
        public MTracker(int id, string name, ITrackerEventPublisher publisher, ITrackerCollector collector)
        {
            _id = id;
            _name = name;
            _publisher = publisher;
            _collector = collector;
        }

        public static MAutoTracker StartNew(MTracker tracker)
        {
            tracker.Start();
            return new MAutoTracker(tracker);
        }

        public void Start()
        {
            if (_isStarted) return;
            
            StartTime = DateTime.Now;
            _isStarted = true;
            
            _publisher?.Publish(new TrackerStartedEvent(this));
        }
        
        public void Stop()
        {
            if(!_isStarted || _isCompleted) return;
            
            EndTime = DateTime.Now;
            _isCompleted = true;
                
            _publisher?.Publish(new TrackerStoppedEvent(this));
        }

        public bool TryGetCollector(out ITrackerCollector collector)
        {
            collector = _collector;
            return _collector != null;
        }
        
        public override string ToString()
        {
            if (!_isCompleted) return "未完成";
            
            var strs = new List<string>();
            var tp = Duration;
    
            strs.Add($"{_id}-{_name}计时：");
            if (tp.Days > 0) strs.Add($"{tp.Days}天");
            if (tp.Hours > 0 || strs.Count > 0) strs.Add($"{tp.Hours}时");
            if (tp.Minutes > 0 || strs.Count > 0) strs.Add($"{tp.Minutes}分");
            strs.Add($"{tp.Seconds}秒");
            strs.Add($"{tp.Milliseconds:000}毫秒");
    
            return string.Join("", strs);
        }
    }

    public static class MTrackerFactory
    {
        public static MTracker CreateTracker(int id, string name)
        {
            return new MTracker(id, name, null, null);
        }
        
        public static MTracker CreateTracker(int id, string name, ITrackerEventPublisher publisher)
        {
            return new MTracker(id, name, publisher, null);
        }
        
        public static MTracker CreateTracker(int id, string name, ITrackerCollector collector)
        {
            return new MTracker(id, name, null, collector);
        }
        
        public static MTracker CreateTracker(int id, string name, ITrackerEventPublisher publisher, ITrackerCollector collector)
        {
            return new MTracker(id, name, publisher, collector);
        }
    }

    public class MAutoTracker : IDisposable
    {
        private readonly MTracker _tracker;
        public MAutoTracker(MTracker tracker) => _tracker = tracker;
        public MTracker Tracker => _tracker;

        public void Dispose()
        {
            _tracker.Stop();
            if (_tracker.TryGetCollector(out var collector))
            {
                collector.Collect(_tracker.ToString());
            }
        }
    }
}
```

